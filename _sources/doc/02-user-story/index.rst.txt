.. raw:: html

   <br/>
   <font color="darkgray">
   <big><big><b>
   Sireum Awas Documentation
   </b></big></big>
   </font>
   <br/>
   <font color="black">
   <big><big><big><big><b>
   2. Sireum Awas Visualizer
   </b></big></big></big></big>
   </font>

Sireum Awas User Stories
########################
.. highlight:: awas

.. raw:: html
	 
    <big><big><big><b>
    <a href="../../_static/simple_uav/index.html" target="_blank">Demo Awas</a> 
    </b></big></big></big>

.. image:: viz_big.png
   :align: center
   :width: 100%
   :target: ../../_static/simple_uav/index.html

Sireum Awas Capabilities
************************

* Model explorer: Enables the user to explore a system's model without
  installing modeling tools. Provides the freedom of refering the
  model from both handheld devices and desktops. The user can hide
  irrelavent part of the model and focus on a specific level of
  modeling detail

----

* Dependency analysis: A system is a composition of components and
  Awas provides insight in the intraction of components using
  component dependency

----

* Risk Analysis: The user can encode abstract error behavior of a
  component as an error token. Using Awas, a user can produce witness
  showcasing the exisistence or lack of errors in the system. This
  token propagation mechanism can be generalized to capture certain
  behavior of the system

	   
Simple UAV System
*****************

Before showing you the various ways you can use Awas, let me describe
a simple example architecture of a UAV surveillance system. The
primary functionality of this UAV is to conduct surveillance over a
specified region. This UAV receives the region information from a
ground station. The UAV itself consists of a computer and a flight
controller. The purpose of the computer is to compute a set of
waypoints from a map and a flight pattern provided by the ground
station. The flight controller act upon these waypoints to progress on
the survillence task. Whenever the UAV reaches a waypoint, it sends
out a status information the ground station.

.. image:: uas.png
   :align: center
   :width: 70%
   :alt: High-level UAV Sysytem 


Model Exploration
*****************

OSATE can produce a system implementation diagram from a system
implementation. The following provides a side by side comparison
between AADL instance diagram and Awas graph for the four systems of
the UAV model.

.. _UAS system:

UAS: The top level system with ground station and UAV
======================================================

.. raw:: html

  <style>
  * {
  box-sizing: border-box;
  }

  .column {
  float: left;
  width: 50%;
  padding: 5px;
  }

  /* Clearfix (clear floats) */
  .row::after {
  content: "";
  clear: both;
  display: table;
  }
  </style>

  <div class="row">
  <div class="column">
  <img src="../../_static/aadl_uas.png" alt="AADL" style="width:1000%">
  </div>
  <div class="column">
  <img src="../../_static/awas_uas.png" alt="Awas" style="width:1000%">
  </div>
  </div>


You can see that both AADL diagram and Awas graph consists of three
components namely GND, UAV, and RFB. However, the similarities end
here, Awas explicitly segregates input and output ports. For in-out
ports, Awas creates two ports one for input and the other for
output. Thus you can see there are two RFA ports in GND component in
the Awas side and only one in the AADL side. This also enables Awas
to separate out the bidirectional connections into two separate
connections.

Awas provides the following capabilities over OSATE:

1. In Awas, the diagrams are interactive
2. Users can click on a node(component and connection), port and edge, and it will get highlighted. 
3. On clicking an edge which represents an AADL connection, Awas
   highlights the edge and also the ports involved in the
   connection. Although, AADL diagrams look cleaner, in a complex
   system edges overlap a lot and it quickly becomes tedious to trace
   each edge.
4.
   .. raw:: html
		  
     This icon <img src="../../_static/sub-graph-icon.png" alt="Sub-graph" style="width:1%"> in front of a component name
     indicates that this node contains a sub-system and the graph
     for the sub-system can be opened by double clicking on the
     component's name
       
     
UAV - Composed of Mission computer and Flight Controller
========================================================

.. raw:: html

  <style>
  * {
  box-sizing: border-box;
  }

  .column {
  float: left;
  width: 50%;
  padding: 5px;
  }

  /* Clearfix (clear floats) */
  .row::after {
  content: "";
  clear: both;
  display: table;
  }
  </style>

  <div class="row">
  <div class="column">
  <img src="../../_static/aadl_uav.png" alt="AADL" style="width:1000%">
  </div>
  <div class="column">
  <img src="../../_static/awas_uav.png" alt="Awas" style="width:1000%">
  </div>
  </div>

In a sub-system graph, Awas creates the parent component's ports as
node. The node ``recv_map`` is same as the port in the UAV component
from the `UAS system`_. Therefore, all interaction on this node are
mimicked on to the port in the parent component.
  

    
Mission computer - Composed of Radio, UART and Software Components
==================================================================

.. raw:: html

  <style>
  * {
  box-sizing: border-box;
  }

  .column {
  float: left;
  width: 50%;
  padding: 5px;
  }

  /* Clearfix (clear floats) */
  .row::after {
  content: "";
  clear: both;
  display: table;
  }
  </style>

  <div class="row">
  <div class="column">
  <img src="../../_static/aadl_mc.png" alt="AADL" style="width:1000%">
  </div>
  <div class="column">
  <img src="../../_static/awas_mc.png" alt="Awas" style="width:1000%">
  </div>
  </div>

You can see that in Awas graph, there are lot more edges when
compared to the AADL diagram. This is due to the edges capturing the
binding relationship. For example, the component ``PROC_SW`` has two
ports ``processor_IN`` and ``processor_OUT`` connecting the component
``PROC_HW``. These edges capture the relation that the ``PROC_SW``
representing the software of the system executes on the hardware
``PROC_HW``. However, AADL diagrams fails to capture these binding
relations and the non trivial information flow through them.
	 

Software - Composed of drivers and logic for computing the waypoints
====================================================================

.. raw:: html

  <style>
  * {
  box-sizing: border-box;
  }

  .column {
  float: left;
  width: 50%;
  padding: 5px;
  }

  /* Clearfix (clear floats) */
  .row::after {
  content: "";
  clear: both;
  display: table;
  }
  </style>

  <div class="row">
  <div class="column">
  <img src="../../_static/aadl_sw.png" alt="AADL" style="width:1000%">
  </div>
  <div class="column">
  <img src="../../_static/awas_sw.png" alt="Awas" style="width:1000%">
  </div>
  </div>
  	 

Awas Visualizer Interface
=========================

* talk briefly about the entire UI

* buttons on the top

* re-organizable windows

* Query view

* CLI interpreter 
  
View Options
============
Using Awas a user can decide what are all the information in a component to view and what to hide. 


.. image:: view_settings.png
   :align: center	   
   :alt: Awas View Settings

Flows
-----

Flows are the dependencies between a componen's input and output
ports. In Awas the user can choose to view these flows or hide them.

.. image:: component_noflow.png
   :align: center
   :width: 50%
   :alt: Component without flow

By selecting the check box in the settings view, one can view the flow
information in components.

In AADL there are three kinds of flows

* Flow source - Information orginates within a component and flows out
  through its output port

* Flow sink - Information flows into a component but does not flows
  out rather it is consumed within the component
  
.. image:: component_flow_2.png
   :align: center	   
   :width: 50%
   :alt: Source and Sink flows

* Flow path - Infomration flows into the component may be just
  propagated out or transoformed and propagated through the component

.. image:: component_flow.png
   :align: center	   
   :width: 50%
   :alt: Flow path

By clicking on a flow Awas can reveal the relationships between a flow
and the ports of a component.

Connections
-----------

In AADL, a user can add behaviors to a connection and these behaviors
are not captured in the AADL instance diagram. However, Awas provides
an option to view or hide this information. Similarly, connections in
AADL can be realized by a component responsible for the transfer of
information such as a networking bus. Again, Awas provides an option
to view or hide these bindings relation.


.. image:: system_bindings.png
   :align: center	   
   :width: 100%
   :alt: Flow path

	 

Dependency Analysis
*******************

In model-based design, typically designing phase is preceded by
requirements gathering phase. During the designing phase, a system
designer develops models satisfying these requirements. At a high
level these requirements are simply connectivity among components. In
order to check for the satisfactory of the requirements by the model
the analyst may pose the following questions and use Awas in the
process of finding the solution.

.. _Query 1: 

Query 1
   If ground station sends the map, Where does information regarding the map flow? and where is it getting consumed?

   A user can use awas by selecting the port ``send_map`` in the
   component ground station and clicking the ``Forward`` button on the
   top of the screen. This highlights the all the ports that receives
   the information from ``send_map``. The flow that is highlighted
   with a darker shade indicates consumption of this information. If
   the user wants to do down the hierarchy they can double click on
   the ``UAV`` component to see the influence of ``send_map`` in the
   subsystems. 

   
.. image:: intra_forward.png
   :align: center	   
   :width: 100%
   :alt: Forward from send_map

.. _Query 2: 
	 
Query 2
   From where does information needed to compute the ``recv_status`` flow from?

   The user can select the port ``recv_status`` and click on the
   ``Backward`` button on the top right of the screen. This action
   highlights all the ports through which the information needed by
   ``recv_status`` flows. Also highlights the flows that sources the
   information in a darker shade.

.. image:: backward_click.png
   :align: center	   
   :width: 100%
   :alt: Backward from recv_status
   
   
Dependency Analysis Using Queries
=================================

Although, the select and click on ``Forward`` or ``Backward`` button
action is simple and quick, it is not easily reproducible by an
automated regression testing suit. To remedy this, we provide a simple
query language an interpreter inside the Awas visualizer. To open the
query interpreter, click on the ``Awas Query`` button on the top right
corner.
 
.. image:: query_view.png
   :align: center	   
   :width: 50%
   :alt: Query View

You can see this tab contains two other tabs

1. Table

   The ``Table`` tab lists the previously executed queries. The color
   in front of each query name indicates the result highlight
   color. The query names are clickable buttons, upon clicking
   highlights the results on the graph. 

2. CLI

   The CLI provides a terminal for entering the queries. This window
   also serves a place to inform any syntax errors on the queries. If
   there exist a solution, this terminal displays the list of graphs
   containing the solution. On successful execution of a query, Awas
   creates a table entry and stores the result to view it again at a
   later time.

   
   
   .. image:: query_forward.png
      :align: center	   
      :width: 100%
      :alt: query forward

	 
   The query ``forward_GND_send_map`` performs the same operation of
   the `Query 1`_. However, using the query rather than the button
   click allows the user to save and execute the same during
   regression testing.

   .. _forward reach query: 

   .. code:: bash

      forward_GND_send_map = reach forward UAS_Impl_Instance.GND.send_map

   In this query statement, the term before ``=`` is the name of the
   query and everything else is the query expression.

   After the ``=``, there are only two possibilities

   1. Primary Query Expression:

      This can be a canonical representation
      of a node, port, or an error token or a previously executed
      query name.
      
   2. Reach Expression:

      All reach expressions start with the term
      ``reach``. The term ``forward`` indicates the direction of
      reachability in this `forward reach query`_. The rest is the
      canonical representation of the port ``send_map``. 
   
Multiple Query Results
----------------------

The last button to discuss at the top right corner is the ``Clear``
button. This button's purpose is to clear the highlights on the
graph. However, without clearing the results, we can display results
of multiple queries at the same time. 

.. image:: query_backward.png
   :align: center	   
   :width: 100%
   :alt: Multiple Query Results

The query ``backward_GND_status`` performs the same action as the
`Query 2`_. By clicking on the button ``backward_GND_status`` without
clearing the result of the previous query we can see the results of
both the queries.
	 
.. code::
	  
   backward_GND_status = reach backward UAS_Impl_Instance.GND.recv_status	 
	 

Complex Queries
===============

The query language's capability goes beyond the simple queries. Using
the queries the analyst can pose some of the interesting questions such as

.. _Query 3: 

Query 3
   when the ground station is sending the map, how does it get to the flight controller?

   The important distinction between `Query 3`_ and the previous
   queries is the number of arguments in the query. In this query, the
   analyst ask is it possible to reach flight controller from ground
   station, if so show how is it possible? in the previous queries we
   asked, how is the information flowing into or out of a specific
   node, port or error token. Here we are asking if we start from a
   source is it possible to reach a destination of interest.


 
Source to Destination Query
---------------------------

.. image:: query_chop.png
   :align: center	   
   :width: 100%
   :alt: Query with source and destination

The following Awas query statement captures the analyst's `Query 3`_

.. code::
   
   GS_flight_controller = reach from UAS_Impl_Instance.GND.send_map to UAS_Impl_Instance.UAV.FCTL.waypoint

This is again a reach expression. However, the direction of the
reachability is replaced by the term ``from`` followed by the
canonical representation of the source of the information and the term
``to`` followed by the destination point of the information flow.

The source and sink can be any two node, port, or error token. If
the source and sink are transitively reachable then Awas will
highlight results or it will inform the lack of information flow.
	 

Path Queries
------------

Although we are able to capture the information flow between a source
and destination, there are multiple ways information can flow from
source to destination. If one wish to enumerate all the individual
paths, they can alter the above Awas query as follows

.. code::
   
   GS_flight_controller_paths = reach paths from UAS_Impl_Instance.GND.send_map to UAS_Impl_Instance.UAV.FCTL.waypoint

The addition of the term ``paths`` instructs Awas to enumerate all the
paths. This suddenly convert the simple reachability problem into a
exponentially complex problem. As there can be infinite number of
paths if there is a cycle in the graph. Our solution to this problem
is to enumerate all the paths without cycles and paths will all the
relevant cycles. Let me explain it a bit, suppose there exist a simple
path A i.e. path without any cycle. Furthermore, assume there are
cycles in the graph and the nodes of the cycles overlap with the nodes
of the path A. Then we create a complex path with all the nodes of the
path A and the cycles whose nodes overlap with path A.

.. image:: query_result.png
   :align: center	   
   :width: 50%
   :alt: Using CLI

In the query view, you can see a little arrow in front of the query
name which indicates the existence of more than one path. On clicking
the arrow, one can view the list of paths. If one wish to obtain only
the paths without any cycle, then they can use the keyword ``simple``.

.. code::
   
   GS_flight_controller_simple_paths = reach simple paths from UAS_Impl_Instance.GND.send_map to UAS_Impl_Instance.UAV.FCTL.waypoint
   
The result of the above query list three paths. Yet, we know there is
only one path from the ground station ``send_map`` to the flight
controller ``waypoint``. This doesn't mean Awas is incorrect. Awas is
producing all the paths which includes the abstract paths that flow
using a components internal flow. To obtain only the refined paths,
one can use the term ``refined`` in the query.
	 

.. code::
   
   GS_flight_controller_refined_paths = reach refined paths from UAS_Impl_Instance.GND.send_map to UAS_Impl_Instance.UAV.FCTL.waypoint
   

.. image:: query_result_ans.png
   :align: center	   
   :width: 100%
   :alt: Query result for refined paths

	 


Path Based Filter
-----------------

What if only some of the paths listed interests the analyst? Or,
analyst wish to see only the paths flowing through a component of
interest. In these situations the filtering capability of Awas come in
handy.

.. _Query 4: 

Query 4
   When the ground station is sending the map, is it always flowing through the filter component?

   The filter component in the ``PROC_SW`` subsystem filters out the
   maps that are not well-formed. An Analyst can check this by asking
   is there a path from ground station to flight controller without
   going through filter. If there are no paths found then we can come
   to a conclusion that all the paths flow through filter. If a path
   exists that does not flow through the filter, Awas will display it.


The following query can Awas query can answer `Query 4`_.

.. code::

    GS_flight_controller_refined_paths = reach refined paths from UAS_Impl_Instance.GND.send_map to UAS_Impl_Instance.UAV.FCTL.waypoint with none(UAS_Impl_Instance.UAV.MCMP.PROC_SW.FTL:port)

On clicking the query name from the query view table, you should see ``The result is empty`` message on the bottom right of the screen.

.. image:: query_refined_path_none.png
   :align: center
   :width: 100%
   :alt: Query path filter

On the above query there are a couple of new terms:

1. ``none``: This term filters the paths that does not contain the node, port, or error token specified. Similarly there are two more terms:
   
   * ``all``: This term filters the paths containing all of the node, port, or error token specified
   * ``some``: This term filters the paths containing at lease one of the specified node, port, or error token

2. ``:port``: This term pulls out all the ports from a component. Similarly one can specify the following self descriptive terms
   
   * ``:node``
   * ``:port-error``
   * ``:in-port``
   * ``:out-port``
   * ``:error``
   * ``:source``
   * ``:sink``

Risk Analysis
*************

With the help of the error token propagation mechanism, the analyst
can model the error behavior of the system. Using Awas, the analyst
can compute the flow of errors in the system and may pose the
following questions:

Query 5
   Is there a possibility of hazardous situation arising over the course of the system operation?

QUery 6
   What are the root causes for a specific hazardous situation?

In our UAV system, we do not have any defined safety constraints
yet. However, we to have some of the security related
properties. Using Awas, the analyst can check some simple behavior
properties. In the UAV system, one of the security property is that,
only the authorized party can communicate with the UAV. We can abuse
the AADL EMV2 mechanism to model these simple properties and use Awas
on top of it.

Query 7
   Is only authorized and well-formed map reaches the flight controller? 

   We can check this using Awas by the following query:

   .. code::

      only_wellformed_authorized = reach paths from (UAS_Impl_Instance.GND.send_map:port-error) to (UAS_Impl_Instance.UAV.FCTL.waypoint:port-error)

      
To view the results, first we have to enable the ``view errors`` check
box in the view settings. On clicking on the query name form the query
view, we can notice only the ``wellformed_authenticated`` token is
highlighted. This shows neither ``unauthenticated`` nor
``not_wellformed`` reaches the flight controller.
   
.. image:: query_error_tokens.png
   :align: center
   :width: 100%
   :alt: Query with error tokens

Roadmap
*******

* Currently the graph rendering and the graph cycles are computed
  during the page load time and when enabling or disabling the ``View
  binding edges``. Therefore, for a large model this may take a while

  - Solution:
    1. Use web workers to parallelly render in the browser
    2. launch a local server when the awas visualizer is opened and process in the server

  .. note::
     Do not perform path queries when the ``View binding
     edges`` option is enabled. For a large system with a lot of
     binding edges, this may take a while to compute.

* Regular expressions to filter the paths

  - Solution:
    
    1. Currently the query language supports regular
       expression. However, the underlying algorithm is not supported.
       

* AADL EMV2 supports state transformation and error behavior
  propagation.

  - Solution:
    
    1. As a first step, weakest precondition calculus is being
       developed on top of Fault Propagation and Transformation
       Calculus(FPTC)

    2. Translate the query specific sub system to AltaRica

       
       

     

 

 
